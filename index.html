<!DOCTYPE html>
<html>
<head>
    <title>Maze Runner - Tilt Control Prototype</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        /* === GLOBAL STYLES & FULL-SCREEN MAP === */
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #6d4c41; /* Darker Wood Tone Background */
            color: white;
            font-family: 'Inter', sans-serif;
            width: 100%;
            height: 100%;
            touch-action: none; /* Prevents default mobile swipe actions */
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-area {
            width: 100%;
            height: 100%;
            position: absolute;
            background-color: #8d6e63; /* Lighter Wood Tone Play Area */
            display: none; /* Hidden until game starts */
            border: 15px solid #5d4037; /* Outer Maze Frame */
            box-sizing: border-box;
        }

        /* === GAME ELEMENTS === */
        #ball {
            position: absolute;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: linear-gradient(145deg, #f0f0f0, #a0a0a0); /* Shiny Metal Look */
            border: 1px solid #333;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        /* Traps (Holes the ball falls into) */
        .trap, #goal-hole {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: #000; /* Black Hole */
            border: 2px solid #333;
            z-index: 5;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.9);
        }
        
        #goal-hole {
            background-color: #cc0000; /* Red End Goal */
            border: 3px dashed #fff;
        }
        
        /* Maze Walls */
        .wall {
            position: absolute;
            background-color: #5d4037; /* Dark Wood Wall Color */
            border-radius: 2px;
            z-index: 8;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
        }

        /* === Menu/Overlay Styles === */
        #start-menu, #game-over, #map-select {
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            z-index: 100;
            width: 80%;
            max-width: 400px;
        }
        
        button {
            padding: 12px 24px;
            margin: 10px;
            font-size: 1.1em;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            transition: all 0.2s;
            box-shadow: 0 4px #388e3c;
        }

        button:active {
            box-shadow: 0 1px #388e3c;
            transform: translateY(3px);
        }
    </style>
</head>
<body>

    <div id="game-container">
        <!-- Map Selection Menu -->
        <div id="map-select">
            <h1>Maze Runner</h1>
            <p>Guide the metal ball to the RED hole!</p>
            <div id="map-buttons">
                <!-- Buttons injected by JavaScript -->
            </div>
        </div>

        <!-- Start Menu (Hidden initially) -->
        <div id="start-menu" style="display: none;">
            <h1 id="course-title"></h1>
            <p>Tilt your phone to begin.</p>
            <button onclick="startGame()">Start Maze</button>
            <button onclick="showMapSelect()">Change Maze</button>
        </div>

        <!-- Game Area -->
        <div id="game-area">
            <div id="ball"></div>
            <div id="goal-hole"></div>
            <!-- Walls and traps dynamically inserted here -->
        </div>

        <!-- Game Over Message (Initially hidden) -->
        <div id="game-over" style="display: none;">
            <h2 id="game-over-message"></h2>
            <button onclick="showMapSelect()">Try Another Maze</button>
        </div>
    </div>

    <script>
        // === CONFIGURATION (Easily Tweakable Values) ===
        const CONFIG = {
            DEAD_ZONE_TILT_THRESHOLD: 5, // Degrees. Tilt must be greater than this to move the ball.
            BASE_SPEED: 0.1,             // Slower base speed for more control
            FRICTION: 0.99,              // High friction (keeps momentum rolling)
            BOUNCE_FACTOR: -0.5,         // Medium bounce off walls
            WALL_THICKNESS: 15           // Thickness of maze walls in pixels
        };

        // === MAP DATA ===
        // Positions and dimensions are in PERCENTAGE (%) for responsiveness.
        const MAP_DATA = [
            {
                id: 0,
                name: "The Beginner's Box",
                startPos: { x: 5, y: 5 },
                goalPos: { x: 90, y: 90 },
                traps: [
                    { x: 30, y: 30 },
                    { x: 70, y: 30 },
                    { x: 50, y: 65 },
                ],
                walls: [
                    // Outer barriers are handled by gameArea borders, these are internal walls.
                    // { type: 'vertical', x: 20, y: 0, h: 40 }, // Example: Vertical wall starting at 20% X, 0% Y, 40% height
                    { type: 'horizontal', x: 20, y: 20, w: 40 },
                    { type: 'vertical', x: 60, y: 20, h: 40 },
                    { type: 'horizontal', x: 40, y: 60, w: 40 },
                    { type: 'vertical', x: 40, y: 40, h: 20 },
                ]
            },
            {
                id: 1,
                name: "The S-Bend Challenge",
                startPos: { x: 90, y: 10 },
                goalPos: { x: 10, y: 90 },
                traps: [
                    { x: 50, y: 10 },
                    { x: 25, y: 50 },
                    { x: 75, y: 50 },
                    { x: 50, y: 90 },
                ],
                walls: [
                    { type: 'horizontal', x: 0, y: 30, w: 70 },
                    { type: 'horizontal', x: 30, y: 70, w: 70 },
                    { type: 'vertical', x: 30, y: 30, h: 40 },
                    { type: 'vertical', x: 70, y: 30, h: 40 },
                ]
            }
        ];

        // --- Game State Variables ---
        let currentMapId = 0;
        let ballX = 0;
        let ballY = 0;
        let velocityX = 0;
        let velocityY = 0;
        let gameActive = false;
        let walls = []; // Stores the current wall DOM elements for collision

        // --- DOM Elements ---
        const ball = document.getElementById('ball');
        const gameArea = document.getElementById('game-area');
        const startMenu = document.getElementById('start-menu');
        const gameOver = document.getElementById('game-over');
        const mapSelect = document.getElementById('map-select');
        const goalHole = document.getElementById('goal-hole');

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            initializeMapButtons();
            // Initial check to ensure the goal hole exists, even if hidden
            if (!goalHole) {
                const newGoal = document.createElement('div');
                newGoal.id = 'goal-hole';
                gameArea.appendChild(newGoal);
            }
        });

        function initializeMapButtons() {
            const container = document.getElementById('map-buttons');
            container.innerHTML = ''; // Clear existing buttons
            MAP_DATA.forEach(map => {
                const button = document.createElement('button');
                button.textContent = map.name;
                button.onclick = () => selectMap(map.id);
                container.appendChild(button);
            });
        }
        
        function showMapSelect() {
            startMenu.style.display = 'none';
            gameArea.style.display = 'none';
            gameOver.style.display = 'none';
            mapSelect.style.display = 'block';
            gameActive = false;
        }

        function selectMap(mapId) {
            currentMapId = mapId;
            const map = MAP_DATA[mapId];
            document.getElementById('course-title').textContent = map.name;
            
            mapSelect.style.display = 'none';
            startMenu.style.display = 'block';
        }

        function startGame() {
            const map = MAP_DATA[currentMapId];
            
            startMenu.style.display = 'none';
            gameOver.style.display = 'none';
            gameArea.style.display = 'block';

            // Reset state
            velocityX = 0;
            velocityY = 0;

            // Apply map layout and start game loop
            loadMap(map);

            gameActive = true;
            
            // Request permission for motion sensors (required on iOS/Safari)
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(permissionState => {
                        if (permissionState === 'granted') {
                            window.addEventListener('devicemotion', handleMotion);
                        } else {
                            // Using a temporary modal/alert replacement for user feedback
                            document.getElementById('game-over-message').textContent = "Motion access denied. Game cannot be played.";
                            gameOver.style.display = 'block';
                        }
                    })
                    .catch(console.error);
            } else {
                window.addEventListener('devicemotion', handleMotion);
            }

            requestAnimationFrame(gameLoop);
        }

        function loadMap(map) {
            // Clear old traps and walls
            document.querySelectorAll('#game-area .trap, #game-area .wall').forEach(el => el.remove());
            walls = [];

            // Helper to convert percentage to pixels
            const toPxX = (pct) => (gameArea.clientWidth * pct) / 100;
            const toPxY = (pct) => (gameArea.clientHeight * pct) / 100;
            const centerOffset = (el) => el.clientWidth / 2;

            // 1. Set ball initial position
            ballX = toPxX(map.startPos.x);
            ballY = toPxY(map.startPos.y);

            // 2. Set goal hole position
            goalHole.style.left = toPxX(map.goalPos.x) - centerOffset(goalHole) + 'px';
            goalHole.style.top = toPxY(map.goalPos.y) - centerOffset(goalHole) + 'px';

            // 3. Add new traps (black holes)
            map.traps.forEach(t => {
                const trapDiv = document.createElement('div');
                trapDiv.className = `trap`;
                trapDiv.style.left = toPxX(t.x) - centerOffset(trapDiv) + 'px';
                trapDiv.style.top = toPxY(t.y) - centerOffset(trapDiv) + 'px';
                gameArea.appendChild(trapDiv);
            });

            // 4. Add walls
            map.walls.forEach(w => {
                const wallDiv = document.createElement('div');
                wallDiv.className = 'wall';
                wallDiv.dataset.type = w.type;

                if (w.type === 'horizontal') {
                    wallDiv.style.left = toPxX(w.x) + 'px';
                    wallDiv.style.top = toPxY(w.y) + 'px';
                    wallDiv.style.width = toPxX(w.w) + 'px';
                    wallDiv.style.height = CONFIG.WALL_THICKNESS + 'px';
                } else if (w.type === 'vertical') {
                    wallDiv.style.left = toPxX(w.x) + 'px';
                    wallDiv.style.top = toPxY(w.y) + 'px';
                    wallDiv.style.width = CONFIG.WALL_THICKNESS + 'px';
                    wallDiv.style.height = toPxY(w.h) + 'px';
                }
                
                gameArea.appendChild(wallDiv);
                walls.push(wallDiv);
            });
            
            ball.style.left = ballX + 'px';
            ball.style.top = ballY + 'px';
        }

        // --- Sensor Handling ---
        function handleMotion(event) {
            if (!gameActive) return;

            const acceleration = event.accelerationIncludingGravity;

            // Calculate a rough degree tilt for dead zone
            const degTiltX = Math.atan(acceleration.x / 9.8) * (180 / Math.PI);
            const degTiltY = Math.atan(acceleration.y / 9.8) * (180 / Math.PI);

            // --- Apply Dead Zone and Inversion ---
            if (Math.abs(degTiltX) > CONFIG.DEAD_ZONE_TILT_THRESHOLD) {
                 // Invert X-axis for correct maze feel
                 velocityX += -acceleration.x * CONFIG.BASE_SPEED; 
            }
            if (Math.abs(degTiltY) > CONFIG.DEAD_ZONE_TILT_THRESHOLD) {
                // Invert Y-axis for correct maze feel
                velocityY += acceleration.y * CONFIG.BASE_SPEED; 
            }
        }


        // --- Main Game Loop ---
        function gameLoop() {
            if (!gameActive) return;

            // 1. Apply Friction/Damping (maintains momentum)
            velocityX *= CONFIG.FRICTION;
            velocityY *= CONFIG.FRICTION;

            // 2. Pre-update position
            let newBallX = ballX + velocityX;
            let newBallY = ballY + velocityY;

            // 3. Wall Collision Check (Internal Walls)
            const ballRect = ball.getBoundingClientRect();
            const ballWidth = ballRect.width;
            const ballHeight = ballRect.height;

            for (const wall of walls) {
                const wallRect = wall.getBoundingClientRect();

                // Check collision at the proposed new position
                if (
                    newBallX < wallRect.right && 
                    newBallX + ballWidth > wallRect.left &&
                    newBallY < wallRect.bottom &&
                    newBallY + ballHeight > wallRect.top
                ) {
                    // Collision detected! Determine direction and adjust
                    
                    // Check horizontal side collision
                    if (ballX >= wallRect.right || ballX + ballWidth <= wallRect.left) {
                        velocityX *= CONFIG.BOUNCE_FACTOR;
                        newBallX = ballX; // Prevent movement in X
                    } 
                    
                    // Check vertical side collision
                    if (ballY >= wallRect.bottom || ballY + ballHeight <= wallRect.top) {
                        velocityY *= CONFIG.BOUNCE_FACTOR;
                        newBallY = ballY; // Prevent movement in Y
                    } 
                }
            }

            // 4. Boundary Collision Check (Maze Frame)
            const maxX = gameArea.clientWidth - ballWidth - CONFIG.WALL_THICKNESS;
            const maxY = gameArea.clientHeight - ballHeight - CONFIG.WALL_THICKNESS;
            const min = CONFIG.WALL_THICKNESS;


            if (newBallX < min) {
                newBallX = min;
                velocityX *= CONFIG.BOUNCE_FACTOR;
            } else if (newBallX > maxX) {
                newBallX = maxX;
                velocityX *= CONFIG.BOUNCE_FACTOR;
            }

            if (newBallY < min) {
                newBallY = min;
                velocityY *= CONFIG.BOUNCE_FACTOR;
            } else if (newBallY > maxY) {
                newBallY = maxY;
                velocityY *= CONFIG.BOUNCE_FACTOR;
            }

            // 5. Update position after collision checks
            ballX = newBallX;
            ballY = newBallY;
            
            // 6. Check for Traps/Goal
            checkCollisions();

            // 7. Update Ball Position on Screen
            ball.style.left = ballX + 'px';
            ball.style.top = ballY + 'px';

            requestAnimationFrame(gameLoop);
        }

        function gameOverScreen(message) {
             gameActive = false;
             gameArea.style.display = 'none';
             gameOver.style.display = 'block';
             document.getElementById('game-over-message').textContent = message;
        }

        // --- Collision Logic ---
        function checkCollisions() {
            const ballRect = ball.getBoundingClientRect();
            const goalRect = goalHole.getBoundingClientRect();
            const traps = document.querySelectorAll('.trap');
            
            // Get ball center position relative to the viewport
            const ballCenter = { 
                x: ballRect.left + ballRect.width / 2, 
                y: ballRect.top + ballRect.height / 2 
            };

            // ** 1. GOAL HOLE COLLISION (Win Condition) **
            if (
                ballCenter.x > goalRect.left &&
                ballCenter.x < goalRect.right &&
                ballCenter.y > goalRect.top &&
                ballCenter.y < goalRect.bottom
            ) {
                gameOverScreen("Success! You guided the ball to the RED hole!");
                return;
            }

            // ** 2. TRAP HOLE COLLISION (Loss Condition) **
            traps.forEach(trap => {
                const trapRect = trap.getBoundingClientRect();
                
                // Check if the center of the ball has fallen into the black hole (trap)
                if (
                    ballCenter.x > trapRect.left &&
                    ballCenter.x < trapRect.right &&
                    ballCenter.y > trapRect.top &&
                    ballCenter.y < trapRect.bottom
                ) {
                    gameOverScreen("Oops! The ball fell into a trap hole!");
                    return;
                }
            });
        }
    </script>
</body>
</html>




