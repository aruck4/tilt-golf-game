<!DOCTYPE html>
<html>
<head>
    <title>Maze Runner - Tilt Control Prototype</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        /* === GLOBAL STYLES & FULL-SCREEN MAP === */
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #6d4c41; /* Darker Wood Tone Background */
            color: white;
            font-family: 'Inter', sans-serif;
            width: 100%;
            height: 100%;
            touch-action: none; /* Prevents default mobile swipe actions */
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-area {
            /* Makes the game area a responsive square based on the smaller screen dimension (vh or vw) */
            width: min(90vh, 90vw);
            height: min(90vh, 90vw);
            position: absolute;
            background-color: #8d6e63; /* Lighter Wood Tone Play Area */
            display: none; /* Hidden until game starts */
            border: 15px solid #5d4037; /* Outer Maze Frame (15px border) */
            box-sizing: border-box;
        }

        /* === GAME ELEMENTS === */
        #ball {
            position: absolute;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: linear-gradient(145deg, #f0f0f0, #a0a0a0); /* Shiny Metal Look */
            border: 1px solid #333;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        /* Traps (Holes the ball falls into) - Increased size to 45px to match image density */
        .trap, #goal-hole {
            position: absolute;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: #000; /* Black Hole */
            border: 2px solid #333;
            z-index: 5;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.9);
        }
        
        #goal-hole {
            background-color: #cc0000; /* Red End Goal */
            border: 3px dashed #fff;
        }
        
        /* Maze Walls (The "Pegs") */
        .wall {
            position: absolute;
            background-color: #5d4037; /* Dark Wood Wall Color */
            border-radius: 2px;
            z-index: 8;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
        }

        /* === Menu/Overlay Styles === */
        #start-menu, #game-over, #map-select {
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            z-index: 100;
            width: 80%;
            max-width: 400px;
        }
        
        button {
            padding: 12px 24px;
            margin: 10px;
            font-size: 1.1em;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            transition: all 0.2s;
            box-shadow: 0 4px #388e3c;
        }

        button:active {
            box-shadow: 0 1px #388e3c;
            transform: translateY(3px);
        }
    </style>
</head>
<body>

    <div id="game-container">
        <!-- Map Selection Menu -->
        <div id="map-select">
            <h1>Maze Runner</h1>
            <p>Guide the metal ball to the RED hole!</p>
            <div id="map-buttons">
                <!-- Buttons injected by JavaScript -->
            </div>
        </div>

        <!-- Start Menu (Hidden initially) -->
        <div id="start-menu" style="display: none;">
            <h1 id="course-title"></h1>
            <p>Tilt your phone to begin.</p>
            <button onclick="startGame()">Start Maze</button>
            <button onclick="showMapSelect()">Change Maze</button>
        </div>

        <!-- Game Area -->
        <div id="game-area">
            <div id="ball"></div>
            <div id="goal-hole"></div>
            <!-- Walls and traps dynamically inserted here -->
        </div>

        <!-- Game Over Message (Initially hidden) -->
        <div id="game-over" style="display: none;">
            <h2 id="game-over-message"></h2>
            <button onclick="showMapSelect()">Try Another Maze</button>
        </div>
    </div>

    <script>
        // === CONFIGURATION (Easily Tweakable Values) ===
        const CONFIG = {
            DEAD_ZONE_TILT_THRESHOLD: 5, // Degrees. Tilt must be greater than this to move the ball.
            BASE_SPEED: 0.1,             // Slower base speed for more control
            FRICTION: 0.99,              // High friction (keeps momentum rolling)
            BOUNCE_FACTOR: -0.5,         // Medium bounce off walls
            WALL_THICKNESS: 0            // This is now calculated dynamically in loadMap for scaling
        };

        // The outer border thickness, used for establishing the true boundary of the playing field.
        const OUTER_BORDER_THICKNESS = 15; 

        // === MAP DATA ===
        // Positions and dimensions are in PERCENTAGE (%) for responsiveness.
        // Designs based on the Labyrinth style (many holes, short wall segments).
        const MAP_DATA = [
            {
                id: 0,
                name: "The Pinball Path (Easy)",
                startPos: { x: 50, y: 5 },
                goalPos: { x: 50, y: 95 },
                traps: [
                    { x: 10, y: 20 }, { x: 90, y: 20 },
                    { x: 30, y: 40 }, { x: 70, y: 40 }, 
                    { x: 10, y: 60 }, { x: 90, y: 60 }, 
                    { x: 30, y: 80 }, { x: 70, y: 80 }, 
                    { x: 50, y: 50 } // Center Trap
                ],
                walls: [
                    // Top Entry Guide (V: vertical, H: horizontal)
                    { type: 'vertical', x: 30, y: 0, h: 20 },
                    { type: 'vertical', x: 70, y: 0, h: 20 },
                    
                    // Left Serpent Curve
                    { type: 'horizontal', x: 20, y: 30, w: 30 }, // Block top-left
                    { type: 'vertical', x: 20, y: 30, h: 20 },
                    { type: 'horizontal', x: 20, y: 50, w: 30 }, // Block middle-left
                    { type: 'vertical', x: 40, y: 60, h: 20 },

                    // Right Serpent Curve
                    { type: 'horizontal', x: 50, y: 70, w: 30 }, // Block bottom-right
                    { type: 'vertical', x: 80, y: 50, h: 20 },
                    { type: 'horizontal', x: 50, y: 30, w: 30 }, // Block middle-right
                    { type: 'vertical', x: 60, y: 20, h: 20 },

                    // Bottom Guide
                    { type: 'horizontal', x: 30, y: 85, w: 40 } // Funnel to the goal
                ]
            },
            {
                id: 1,
                name: "The Winding Gauntlet (Hard)",
                startPos: { x: 5, y: 5 },
                goalPos: { x: 95, y: 95 },
                traps: [
                    // Dense trap placement
                    { x: 30, y: 15 }, { x: 70, y: 15 }, 
                    { x: 15, y: 30 }, { x: 50, y: 30 }, { x: 85, y: 30 },
                    { x: 30, y: 45 }, { x: 70, y: 45 }, 
                    { x: 15, y: 60 }, { x: 50, y: 60 }, { x: 85, y: 60 },
                    { x: 30, y: 75 }, { x: 70, y: 75 },
                    { x: 50, y: 90 } // Near goal trap
                ],
                walls: [
                    // --- Top Left Quadrant (Start 5, 5) ---
                    { type: 'horizontal', x: 20, y: 20, w: 30 }, // Blocks straight across from start
                    { type: 'vertical', x: 45, y: 20, h: 25 },  // Forces ball down

                    // --- Left-to-Right Crossover Channel (Y=45-70) ---
                    { type: 'horizontal', x: 0, y: 40, w: 45 }, // Top block of channel (Y=40)
                    { type: 'horizontal', x: 55, y: 40, w: 45 }, // Top block, forces entry near center (Y=40)
                    { type: 'vertical', x: 55, y: 40, h: 30 },  // Central divider peg 1 (Y=40 to Y=70)

                    // --- Bottom Block and Final Corner (Y=70-100) ---
                    { type: 'horizontal', x: 20, y: 70, w: 60 }, // Main horizontal divider (Forces ball into X>80)
                    { type: 'vertical', x: 20, y: 70, h: 25 },  // Left side guide (Y=70 to Y=95)
                    
                    // FIX: New, shorter pegs to define the open goal path at (95, 95)
                    { type: 'vertical', x: 80, y: 70, h: 15 },  // Peg 1: Forces ball down to Y=85
                    { type: 'horizontal', x: 80, y: 85, w: 10 } // Peg 2: Forces ball right past X=90
                    // The path is now clear to the goal at (95, 95)
                ]
            }
        ];

        // --- Game State Variables ---
        let currentMapId = 0;
        let ballX = 0;
        let ballY = 0;
        let velocityX = 0;
        let velocityY = 0;
        let gameActive = false;
        let walls = []; // Stores the current wall hitbox data (not just the elements)

        // --- DOM Elements ---
        const ball = document.getElementById('ball');
        const gameArea = document.getElementById('game-area');
        const startMenu = document.getElementById('start-menu');
        const gameOver = document.getElementById('game-over');
        const mapSelect = document.getElementById('map-select');
        const goalHole = document.getElementById('goal-hole');

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            initializeMapButtons();
            // Initial check to ensure the goal hole exists, even if hidden
            if (!goalHole) {
                const newGoal = document.createElement('div');
                newGoal.id = 'goal-hole';
                gameArea.appendChild(newGoal);
            }
        });

        function initializeMapButtons() {
            const container = document.getElementById('map-buttons');
            container.innerHTML = ''; // Clear existing buttons
            MAP_DATA.forEach(map => {
                const button = document.createElement('button');
                button.textContent = map.name;
                button.onclick = () => selectMap(map.id);
                container.appendChild(button);
            });
        }
        
        function showMapSelect() {
            startMenu.style.display = 'none';
            gameArea.style.display = 'none';
            gameOver.style.display = 'none';
            mapSelect.style.display = 'block';
            gameActive = false;
        }

        function selectMap(mapId) {
            currentMapId = mapId;
            const map = MAP_DATA[mapId];
            document.getElementById('course-title').textContent = map.name;
            
            mapSelect.style.display = 'none';
            startMenu.style.display = 'block';
        }

        function startGame() {
            const map = MAP_DATA[currentMapId];
            
            startMenu.style.display = 'none';
            gameOver.style.display = 'none';
            gameArea.style.display = 'block';

            // Reset state
            velocityX = 0;
            velocityY = 0;

            // Apply map layout and start game loop
            loadMap(map);

            gameActive = true;
            
            // Request permission for motion sensors (required on iOS/Safari)
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(permissionState => {
                        if (permissionState === 'granted') {
                            window.addEventListener('devicemotion', handleMotion);
                        } else {
                            // Using a temporary modal/alert replacement for user feedback
                            document.getElementById('game-over-message').textContent = "Motion access denied. Game cannot be played.";
                            gameOver.style.display = 'block';
                        }
                    })
                    .catch(console.error);
            } else {
                window.addEventListener('devicemotion', handleMotion);
            }

            requestAnimationFrame(gameLoop);
        }

        function loadMap(map) {
            // Clear old traps and walls
            document.querySelectorAll('#game-area .trap, #game-area .wall').forEach(el => el.remove());
            walls = [];

            // Helper to convert percentage to pixels (relative to inner content area)
            const toPxX = (pct) => (gameArea.clientWidth * pct) / 100;
            const toPxY = (pct) => (gameArea.clientHeight * pct) / 100;
            const centerOffset = (el) => el.clientWidth / 2;

            // ** SCALING FIX: Calculate dynamic wall thickness based on 1.5% of game area **
            const dynamicWallThickness = Math.floor(gameArea.clientWidth * 0.015); 
            CONFIG.WALL_THICKNESS = dynamicWallThickness;


            // 1. Set ball initial position
            const ballWidth = ball.offsetWidth;
            
            // FIX: Add OUTER_BORDER_THICKNESS to ballX/Y so the position is relative to the game-area's top-left corner (not the inner content area).
            ballX = toPxX(map.startPos.x) - (ballWidth / 2) + OUTER_BORDER_THICKNESS;
            ballY = toPxY(map.startPos.y) - (ballWidth / 2) + OUTER_BORDER_THICKNESS;

            // 2. Set goal hole position
            // FIX: Add OUTER_BORDER_THICKNESS to align with the new coordinate system
            goalHole.style.left = toPxX(map.goalPos.x) - centerOffset(goalHole) + OUTER_BORDER_THICKNESS + 'px';
            goalHole.style.top = toPxY(map.goalPos.y) - centerOffset(goalHole) + OUTER_BORDER_THICKNESS + 'px';

            // 3. Add new traps (black holes)
            map.traps.forEach(t => {
                const trapDiv = document.createElement('div');
                trapDiv.className = `trap`;
                // FIX: Add OUTER_BORDER_THICKNESS to align with the new coordinate system
                trapDiv.style.left = toPxX(t.x) - centerOffset(trapDiv) + OUTER_BORDER_THICKNESS + 'px';
                trapDiv.style.top = toPxY(t.y) - centerOffset(trapDiv) + OUTER_BORDER_THICKNESS + 'px';
                gameArea.appendChild(trapDiv);
            });

            // 4. Add walls
            map.walls.forEach(w => {
                const wallDiv = document.createElement('div');
                wallDiv.className = 'wall';
                wallDiv.dataset.type = w.type;
                
                let left, top, width, height;

                if (w.type === 'horizontal') {
                    left = toPxX(w.x);
                    top = toPxY(w.y);
                    width = toPxX(w.w);
                    height = CONFIG.WALL_THICKNESS;
                } else if (w.type === 'vertical') {
                    left = toPxX(w.x);
                    top = toPxY(w.y);
                    width = CONFIG.WALL_THICKNESS;
                    height = toPxY(w.h);
                }

                // FIX: Apply the border offset to the CSS position
                const finalLeft = left + OUTER_BORDER_THICKNESS;
                const finalTop = top + OUTER_BORDER_THICKNESS;

                wallDiv.style.left = finalLeft + 'px';
                wallDiv.style.top = finalTop + 'px';
                wallDiv.style.width = width + 'px';
                wallDiv.style.height = height + 'px';
                
                gameArea.appendChild(wallDiv);
                
                // Store calculated pixel values for collision (Source of Truth)
                // These coordinates are relative to the top-left of the game-area box.
                walls.push({
                    element: wallDiv,
                    left: finalLeft,
                    top: finalTop,
                    right: finalLeft + width,
                    bottom: finalTop + height
                });
            });
            
            ball.style.left = ballX + 'px';
            ball.style.top = ballY + 'px';
        }

        // --- Sensor Handling ---
        function handleMotion(event) {
            if (!gameActive) return;

            const acceleration = event.accelerationIncludingGravity;

            // Calculate a rough degree tilt for dead zone
            const degTiltX = Math.atan(acceleration.x / 9.8) * (180 / Math.PI);
            const degTiltY = Math.atan(acceleration.y / 9.8) * (180 / Math.PI);

            // --- Apply Dead Zone and Inversion ---
            if (Math.abs(degTiltX) > CONFIG.DEAD_ZONE_TILT_THRESHOLD) {
                 // Invert X-axis for correct maze feel
                 velocityX += -acceleration.x * CONFIG.BASE_SPEED; 
            }
            if (Math.abs(degTiltY) > CONFIG.DEAD_ZONE_TILT_THRESHOLD) {
                // Invert Y-axis for correct maze feel
                velocityY += acceleration.y * CONFIG.BASE_SPEED; 
            }
        }


        // --- Main Game Loop ---
        function gameLoop() {
            if (!gameActive) return;

            // 1. Apply Friction/Damping (maintains momentum)
            velocityX *= CONFIG.FRICTION;
            velocityY *= CONFIG.FRICTION;

            // 2. Pre-update position
            let newBallX = ballX + velocityX;
            let newBallY = ballY + velocityY;

            // 3. Wall Collision Check (Internal Walls)
            const ballWidth = ball.offsetWidth;
            const ballHeight = ball.offsetHeight;

            // Collision check using the pre-calculated, pixel-perfect wall hitboxes
            for (const wallData of walls) {
                const wallRelative = {
                    left: wallData.left,
                    right: wallData.right,
                    top: wallData.top,
                    bottom: wallData.bottom
                };

                // Check collision at the proposed new position (AABB check)
                if (
                    newBallX < wallRelative.right && 
                    newBallX + ballWidth > wallRelative.left &&
                    newBallY < wallRelative.bottom &&
                    newBallY + ballHeight > wallRelative.top
                ) {
                    // Collision detected! Use Minimum Translation Vector (MTV) to resolve penetration.
                    
                    // 1. Calculate Overlap
                    const overlapX = Math.min(
                        wallRelative.right - newBallX,          // Overlap from the right side
                        (newBallX + ballWidth) - wallRelative.left // Overlap from the left side
                    );
                    
                    const overlapY = Math.min(
                        wallRelative.bottom - newBallY,         // Overlap from the bottom side
                        (newBallY + ballHeight) - wallRelative.top // Overlap from the top side
                    );

                    // 2. Resolve on the axis with the LEAST overlap (MTV)
                    if (overlapX < overlapY) {
                        // Horizontal collision (resolve X)
                        velocityX *= CONFIG.BOUNCE_FACTOR; 

                        const ballCenterX = newBallX + ballWidth / 2;
                        const wallCenterX = (wallRelative.left + wallRelative.right) / 2;

                        if (ballCenterX < wallCenterX) {
                            // Push ball to the left edge of the wall
                            newBallX = wallRelative.left - ballWidth;
                        } else {
                            // Push ball to the right edge of the wall
                            newBallX = wallRelative.right;
                        }
                    } else {
                        // Vertical collision (resolve Y)
                        velocityY *= CONFIG.BOUNCE_FACTOR; 

                        const ballCenterY = newBallY + ballHeight / 2;
                        const wallCenterY = (wallRelative.top + wallRelative.bottom) / 2;

                        if (ballCenterY < wallCenterY) {
                            // Push ball up to the top edge of the wall
                            newBallY = wallRelative.top - ballHeight;
                        } else {
                            // Push ball down to the bottom edge of the wall
                            newBallY = wallRelative.bottom;
                        }
                    }
                }
            }

            // 4. Boundary Collision Check (Maze Frame)
            const innerContentWidth = gameArea.clientWidth;

            // The minimum position (left/top) must be the border thickness itself (15px).
            const min = OUTER_BORDER_THICKNESS;

            // The maximum position (right/bottom) is the border (15px) + inner content width - ball width.
            const maxX = innerContentWidth + OUTER_BORDER_THICKNESS - ballWidth;
            const maxY = gameArea.clientHeight + OUTER_BORDER_THICKNESS - ballHeight;


            if (newBallX < min) {
                newBallX = min;
                velocityX *= CONFIG.BOUNCE_FACTOR;
            } else if (newBallX > maxX) {
                newBallX = maxX;
                velocityX *= CONFIG.BOUNCE_FACTOR;
            }

            if (newBallY < min) {
                newBallY = min;
                velocityY *= CONFIG.BOUNCE_FACTOR;
            } else if (newBallY > maxY) {
                newBallY = maxY;
                velocityY *= CONFIG.BOUNCE_FACTOR;
            }

            // 5. Update position after collision checks
            ballX = newBallX;
            ballY = newBallY;
            
            // 6. Check for Traps/Goal
            checkCollisions();

            // 7. Update Ball Position on Screen
            ball.style.left = ballX + 'px';
            ball.style.top = ballY + 'px';

            requestAnimationFrame(gameLoop);
        }

        function gameOverScreen(message) {
             gameActive = false;
             gameArea.style.display = 'none';
             gameOver.style.display = 'block';
             document.getElementById('game-over-message').textContent = message;
        }

        // --- Collision Logic ---
        function checkCollisions() {
            // Use internal game area coordinates (ballX, ballY) for all collision checks.
            const ballSize = ball.offsetWidth;
            const ballCenter = { 
                x: ballX + ballSize / 2, 
                y: ballY + ballSize / 2 
            };

            const goalLeft = parseFloat(goalHole.style.left);
            const goalTop = parseFloat(goalHole.style.top);
            const goalSize = goalHole.offsetWidth;
            
            // ** 1. GOAL HOLE COLLISION (Win Condition) **
            // Check if the ball center is within the goal's bounding box
            if (
                ballCenter.x > goalLeft &&
                ballCenter.x < goalLeft + goalSize &&
                ballCenter.y > goalTop &&
                ballCenter.y < goalTop + goalSize
            ) {
                gameOverScreen("Success! You guided the ball to the RED hole!");
                return;
            }

            // ** 2. TRAP HOLE COLLISION (Loss Condition) **
            const traps = document.querySelectorAll('.trap');
            for (const trap of traps) {
                const trapLeft = parseFloat(trap.style.left);
                const trapTop = parseFloat(trap.style.top);
                const trapSize = trap.offsetWidth;
                
                // If the ball center falls within the trap's bounding box
                if (
                    ballCenter.x > trapLeft &&
                    ballCenter.x < trapLeft + trapSize &&
                    ballCenter.y > trapTop &&
                    ballCenter.y < trapTop + trapSize
                ) {
                    gameOverScreen("Oops! The ball fell into a trap hole!");
                    return;
                }
            }
        }
    </script>
</body>
</html>
